{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/hello-world.md","shasum":"774b507901d9b17991ace2a70263b6dd6d11999a","modified":1453899482309},{"_id":"source/_posts/json-best-practice.md","shasum":"2d995277d62c9c20dea3c8f12b1ecc35564f824b","modified":1496761673387},{"_id":"source/about/index.md","shasum":"9b3b32f312ba291da77a3582f45a9064cc5524b2","modified":1453904503169},{"_id":"source/_posts/oracle2mysql01.md","shasum":"227d33d5f207b67c5c02cbdfc8a16acec5de93ec","modified":1495722530741},{"_id":"public/js/totop.js","modified":1496761301460,"shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb"},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","modified":1496761301466,"shasum":"57c3987166a26415a71292162690e82c21e315ad"},{"_id":"public/js/jquery.imagesloaded.min.js","modified":1496761301471,"shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f"},{"_id":"public/js/jquery-2.0.3.min.js","modified":1496761301476,"shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d"},{"_id":"public/js/gallery.js","modified":1496761301485,"shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed"},{"_id":"public/img/scrollup.png","modified":1496761301493,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/img/logo.svg","modified":1496761301499,"shasum":"0eb0ae32d95c6f0b14adb9ab491775dcd1da3af3"},{"_id":"public/img/logo.png","modified":1496761301504,"shasum":"d393075244e6f1290226376b636ea88a2ed80704"},{"_id":"public/img/jacman.jpg","modified":1496761301506,"shasum":"36d7503393422d70807bd0b248ba92e0cd62fe46"},{"_id":"public/img/favicon.ico","modified":1496761301515,"shasum":"59792f8eea6aa0f176fb20195a34c3d3305549b6"},{"_id":"public/img/cc-zero.svg","modified":1496761301520,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/img/cc-by.svg","modified":1496761301524,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/img/cc-by-sa.svg","modified":1496761301528,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/img/cc-by-nd.svg","modified":1496761301532,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/img/cc-by-nc.svg","modified":1496761301534,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/img/cc-by-nc-sa.svg","modified":1496761301537,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/img/cc-by-nc-nd.svg","modified":1496761301541,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/img/banner.jpg","modified":1496761301549,"shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74"},{"_id":"public/img/author.jpg","modified":1496761301556,"shasum":"091f7c03f0e81979b64a6e4ce1f749a5eba0386b"},{"_id":"public/font/fontdiao.woff","modified":1496761301561,"shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f"},{"_id":"public/font/fontdiao.ttf","modified":1496761301564,"shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab"},{"_id":"public/font/fontdiao.svg","modified":1496761301568,"shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b"},{"_id":"public/font/fontdiao.eot","modified":1496761301571,"shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1496761301574,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1496761301576,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1496761301581,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/font/fontawesome-webfont.eot","modified":1496761301586,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1496761301589,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1496761301594,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1496761301600,"shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1496761301604,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1496761301607,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1496761301611,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1496761301615,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1496761301619,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1496761301622,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1496761301624,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1496761301626,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1496761301629,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1496761301632,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1496761301638,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1496761301642,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1496761301646,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1496761301650,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1496761301654,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1496761301658,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1496761301663,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1496761302365,"shasum":"ace9c3df88af85f862060a4cdd5d4716c9a2e5fc"},{"_id":"public/about/index.html","modified":1496762797226,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/2017/06/06/json-best-practice/index.html","modified":1496762797233,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/2017/05/25/oracle2mysql01/index.html","modified":1496762797243,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/2017/05/22/hello-world/index.html","modified":1496762797252,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/index.html","modified":1496762797263,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/2017/index.html","modified":1496762797271,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/2017/05/index.html","modified":1496762797281,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/2017/06/index.html","modified":1496762797287,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/index.html","modified":1496762797309,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/tags/oracle-mysql-database/index.html","modified":1496762797297,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/tags/json/index.html","modified":1496762797303,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"}],"Category":[],"Data":[],"Page":[{"_content":"title:关于我\n---\nWelcome to kimmking's blog on github.io.\n\n## Quick Start\n\n### KimmKing\n\n``` JavaScript\nvar kimmking = new Programmer();\nkimmking.writeblog(new BlogPost());\nkimmking.addEmail(\"kimmking@163.com\");\nkimmking.sayHello();\n\n```\n\nMore info: [blog](http://blog.csdn.net/kimmking)\n\n","source":"about/index.md","raw":"title:关于我\n---\nWelcome to kimmking's blog on github.io.\n\n## Quick Start\n\n### KimmKing\n\n``` JavaScript\nvar kimmking = new Programmer();\nkimmking.writeblog(new BlogPost());\nkimmking.addEmail(\"kimmking@163.com\");\nkimmking.sayHello();\n\n```\n\nMore info: [blog](http://blog.csdn.net/kimmking)\n\n","date":"2016-01-27T14:21:43.169Z","updated":"2016-01-27T14:21:43.169Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cj3lp165a00010wkc2bc0f507"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"title: Hello World\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-05-22T15:37:02.711Z","updated":"2016-01-27T12:58:02.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3lp164g00000wkctxncaphp"},{"title":"企业应用系统由oracle迁移到mysql数据库","date":"2017-05-25T12:10:42.000Z","_content":"传统的中小企业应用中，使用oracle的系统占比较多。迁移到云环境mysql数据库的情况下，需要考虑诸多因素，可用性、效率等。针对阿里云上的系统迁移情况来看，中小企业为主，迁移的应用数量比较大，所用技术五花八门，人肉处理的工作量非常大，效率较低。\n\n## 1.整体思路\n\n最主要的思路是：\n1. 先考虑可用性、跑起来，DDL+数据迁移，基本的DML，程序的修改和调整，\n2. 再考虑高性能高可用高扩展，性能优化，分库分表支持，\n3. 中间可以积累一些通用的框架和平台工具，比如：\n   - 数据库反向建模与DDL生成，基于EMF、GMF之类的\n   - 程序的SQL扫描处理，自动发现\n   - DML转换工具，基于下面第二节的考虑要素\n   - 数据迁移工具，这个应该相对比较成熟\n   - 在线性能度量和优化工具，这个阿里应该也有积累\n   - 将上述工具平台化，并串起来，自动评估企业应用的去O上云复杂度，评估成本\n4. 长期来看，应该基于一些友商，比如用友、金蝶、中软、中科软、中科软等一些固定产品做一些封装和深度定制合作，解决同一类平台上的不同应用系统的去O工作。\n5. 对于特定的一些行业信息化系统，也有一些类型特点，可以积累一些行业类的迁移解决方案。\n\n## 2.数据库修改\n\n### DDL\n- 反向成模型，再生成mysql或其他数据库，主要是数据类型转换，主外键、约束\n- 处理sequence与自增\n\n### DML\n必须改、可以改可以不改、不用改\n\n### 触发器、存储过程\n- 避免，如有需要重写，考虑sql或代码里重写\n\n## 3.程序修改\n\n- 写在代码里的SQL拼装，全文检索或语法分析获取\n- 写在xml里的mapping\n- 写在HQL类的转换引擎隐式SQL\n- 扫描代码、properties和xml\n- JDBC驱动、druid等proxy拦截SQL，系统日志过滤SQL\n- 尽量单表的简单操作，便于移植\n- 如果原先代码里没有用ORM类框架，可以使用快速的脚手架，这套脚手架可以快速的应用到不同的目标数据库，通用性的编程性基础设施都应该是一致和完备的，类似hibernate的思想。\n\n## 4.数据迁移\n### 全量+增量\n\n\n## 5.性能\n优化应该积累成规则，一起做到框架中去，最好能在运行期收集指标信息，持续动态优化，\n### hint\n### 子查询\n### 函数与索引\n\n## 6.扩展性\n### 分库分表\n\n## 7.应用场景\n\n这些工作经过积累沉淀为平台工具后，可以开源出来大家共同维护，也可以在阿里云上作为自助服务式的在线工具，提供给中小企业的技术人员直接操作转换自己的线下应用到云上。\n另一方面，企业内部可能有多种不同的孤立数据源，经过这些工具转换以后，可以比较容易的在阿里云上进一步进行数据的整合，形成企业大数据中心，作为发展企业大数据的出发点。\n\n\n补充：与阿里云去O团队沟通了解，目前做的工作大概就是这个思路，很多东西比这些要更深。","source":"_posts/oracle2mysql01.md","raw":"title: 企业应用系统由oracle迁移到mysql数据库\ndate: 2017-05-25 20:10:42\ntags: oracle mysql database\n---\n传统的中小企业应用中，使用oracle的系统占比较多。迁移到云环境mysql数据库的情况下，需要考虑诸多因素，可用性、效率等。针对阿里云上的系统迁移情况来看，中小企业为主，迁移的应用数量比较大，所用技术五花八门，人肉处理的工作量非常大，效率较低。\n\n## 1.整体思路\n\n最主要的思路是：\n1. 先考虑可用性、跑起来，DDL+数据迁移，基本的DML，程序的修改和调整，\n2. 再考虑高性能高可用高扩展，性能优化，分库分表支持，\n3. 中间可以积累一些通用的框架和平台工具，比如：\n   - 数据库反向建模与DDL生成，基于EMF、GMF之类的\n   - 程序的SQL扫描处理，自动发现\n   - DML转换工具，基于下面第二节的考虑要素\n   - 数据迁移工具，这个应该相对比较成熟\n   - 在线性能度量和优化工具，这个阿里应该也有积累\n   - 将上述工具平台化，并串起来，自动评估企业应用的去O上云复杂度，评估成本\n4. 长期来看，应该基于一些友商，比如用友、金蝶、中软、中科软、中科软等一些固定产品做一些封装和深度定制合作，解决同一类平台上的不同应用系统的去O工作。\n5. 对于特定的一些行业信息化系统，也有一些类型特点，可以积累一些行业类的迁移解决方案。\n\n## 2.数据库修改\n\n### DDL\n- 反向成模型，再生成mysql或其他数据库，主要是数据类型转换，主外键、约束\n- 处理sequence与自增\n\n### DML\n必须改、可以改可以不改、不用改\n\n### 触发器、存储过程\n- 避免，如有需要重写，考虑sql或代码里重写\n\n## 3.程序修改\n\n- 写在代码里的SQL拼装，全文检索或语法分析获取\n- 写在xml里的mapping\n- 写在HQL类的转换引擎隐式SQL\n- 扫描代码、properties和xml\n- JDBC驱动、druid等proxy拦截SQL，系统日志过滤SQL\n- 尽量单表的简单操作，便于移植\n- 如果原先代码里没有用ORM类框架，可以使用快速的脚手架，这套脚手架可以快速的应用到不同的目标数据库，通用性的编程性基础设施都应该是一致和完备的，类似hibernate的思想。\n\n## 4.数据迁移\n### 全量+增量\n\n\n## 5.性能\n优化应该积累成规则，一起做到框架中去，最好能在运行期收集指标信息，持续动态优化，\n### hint\n### 子查询\n### 函数与索引\n\n## 6.扩展性\n### 分库分表\n\n## 7.应用场景\n\n这些工作经过积累沉淀为平台工具后，可以开源出来大家共同维护，也可以在阿里云上作为自助服务式的在线工具，提供给中小企业的技术人员直接操作转换自己的线下应用到云上。\n另一方面，企业内部可能有多种不同的孤立数据源，经过这些工具转换以后，可以比较容易的在阿里云上进一步进行数据的整合，形成企业大数据中心，作为发展企业大数据的出发点。\n\n\n补充：与阿里云去O团队沟通了解，目前做的工作大概就是这个思路，很多东西比这些要更深。","slug":"oracle2mysql01","published":1,"updated":"2017-05-25T14:28:50.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3lp165q00020wkcxsgabo3a"},{"title":"JSON最佳实践","date":"2017-06-06T15:00:05.000Z","_content":"JSON是一种文本方式展示结构化数据的方式，从产生的时候开始就由于其简单好用、跨平台，特别适合HTTP下数据的传输（例如现在很流行的REST）而被广泛使用。\n\n## 1、JSON是什么\nJSON起源于1999年的[JS语言规范ECMA262的一个子集](http://javascript.crockford.com/)（即15.12章节描述了格式与解析），后来2003年作为一个数据格式[ECMA404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)（很囧的序号有不有？）发布。\n2006年，作为[rfc4627](http://www.ietf.org/rfc/rfc4627.txt)发布，这时规范增加到18页，去掉没用的部分，十页不到。\n\nJSON的应用很广泛，这里有超过100种语言下的JSON库：[json.org](http://www.json.org/)。\n\n更多的可以参考这里，[关于json的一切](https://github.com/burningtree/awesome-json)。\n\n\n## 2、优缺点、标准与schema\n### 2.1 结构与类型\n这估计是最简单标准规范之一：\n- 只有两种结构：对象内的键值对集合结构和数组，对象用{}表示、内部是\"key\":\"value\"，数组用[]表示，不同值用逗号分开\n- 基本数值有7个： false / null / true / object / array / number / string\n- 再加上结构可以嵌套，进而可以用来表达复杂的数据\n\n一个简单实例：\n \n```javascript\n\n   {\n      \"Image\": {\n          \"Width\":  800,\n          \"Height\": 600,\n          \"Title\":  \"View from 15th Floor\",\n          \"Thumbnail\": {\n              \"Url\":    \"http://www.example.com/image/481989943\",\n              \"Height\": 125,\n              \"Width\":  \"100\"\n          },\n          \"IDs\": [116, 943, 234, 38793]\n        }\n   }\n\n\n```\n\n### 2.2 优点\n- 基于纯文本，所以对于人类阅读是很友好的。\n- 规范简单，所以容易处理，开箱即用，特别是JS类的ECMA脚本里是内建支持的，可以直接作为对象使用。\n- 平台无关性，因为类型和结构都是平台无关的，而且好处理，容易实现不同语言的处理类库，可以作为多个不同异构系统之间的数据传输格式协议，特别是在HTTP/REST下的数据格式。\n\n### 2.3 缺点\n缺点也很明显：\n- 性能一般，文本表示的数据一般来说比二进制大得多，在数据传输上和解析处理上都要更影响性能。\n- 缺乏schema，跟同是文本数据格式的XML比，在类型的严格性和丰富性上要差很多。XML可以借由XSD或DTD来定义复杂的格式，并由此来验证XML文档是否符合格式要求，甚至进一步的，可以基于XSD来生成具体语言的操作代码，例如apache xmlbeans。并且这些工具组合到一起，形成一套庞大的生态，例如基于XML可以实现SOAP和WSDL，一系列的ws-*规范。但是我们也可以看到JSON在缺乏规范的情况下，实际上有更大一些的灵活性，特别是近年来REST的快速发展，已经有一些schema相关的发展(例如[理解JSON Schema](https://spacetelescope.github.io/understanding-json-schema/index.html)，[使用JSON Schema](http://usingjsonschema.com/downloads/)， [在线schema测试](http://azimi.me/json-schema-view/demo/demo.html))，也有类似于WSDL的[WADL](https://www.w3.org/Submission/wadl/)出现。\n\n## 3. 常用技术与工具\n### 3.1 相关技术以及与XML的关系\n- 使用JSON实现RPC（类似XML-RPC）：[JSON-RPC](http://www.jsonrpc.org/)\n- 使用JSON实现path查询操作（类似XML-PATH）：[JsonPATH](https://github.com/json-path/JsonPath)\n- 在线查询工具：[JsonPATH](http://jsonpath.com/)\n \n例如上面的示例json，用表达式$.Image.IDs[:1]查询，得到116：\n![image](https://raw.githubusercontent.com/kimmking/kk/master/images/json/jsonpath.png)\n\n\n我们看到JSON与XML是如此之像，实际上这两个格式可以看做一个是学院排，一个是平民派。一个对象从POJO转换成XML与JSON的过程，基本是一致的（绝大部分工作可以复用，以后有机会再详细聊这个过程），10年前我自己也做过一个基于XML的RPC（[http://code.google.com/p/rpcfx/](http://code.google.com/p/rpcfx/)，貌似已经被墙），里面实现了java和dotnet、JS的XML序列化与反序列化，同时作为一个副产品，实现了JSON序列化。\n\n后来thoughtsworks公司出品的XStream就是同时做了XML与JSON的序列化。而创建Jackson库的组织本来叫fasterxml，就是处理xml的。当然从这个角度来看，Fastjson库，稍微改改也是一个高性能的XML序列化库。\n只是XML有着更严格的结构，更丰富的工具生态，拿查询与操作来说，XML还有XQuery、XLST等工具。处理方式上也有DOM方式与SAX流模式，这两个绝然不同的技术。\n\n单从性能来考虑，XML更是有[VTD-XML](http://vtd-xml.sourceforge.net/)这种解决了DOM消耗太大内存与SAX只能单向每个节点读一次不能随机读的缺点的高性能处理方式。\n\n### 3.2 Java类库\n- [Fastjson](https://github.com/alibaba/fastjson)\n- [Jackson](http://wiki.fasterxml.com/JacksonHome)\n- [Gson](https://github.com/google/gson)\n- [Xstream](http://x-stream.github.io/)\n\n### 3.3 工具\n- 格式化工具：[jsbeautifier](http://jsbeautifier.org/)\n- chrome插件：[5个Json View插件](http://www.cnplugins.com/zhuanti/five-chrome-json-plugins.html)\n- 在线Mock: [在线mock](https://www.easy-mock.com/)\n- 其他Mock：[SoapUI](https://www.soapui.org/rest-testing-mocking/rest-service-mocking.html)可以支持，SwaggerUI也可以，[RestMock](https://github.com/andrzejchm/RESTMock)也可以。\n\n![image](https://github.com/kimmking/kk/blob/master/images/json/json01.png?raw=true)\n![image](https://github.com/kimmking/kk/blob/master/images/json/json02.png?raw=true)\n\n## 4. JSON编码指南\n### 4.1 Google JSON风格指南\n遵循好的设计与编码风格，能提前解决80%的问题:\n- 英文版[Google JSON Style Guide](https://google.github.io/styleguide/jsoncstyleguide.xml)：https://google.github.io/styleguide/jsoncstyleguide.xml\n- 中文版[Google JSON风格指南](https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md)：https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md\n\n简单摘录如下：\n- 属性名和值都是用双引号，不要把注释写到对象里面，对象数据要简洁\n- 不要随意结构化分组对象，推荐是用扁平化方式，层次不要太复杂\n- 命名方式要有意义，比如单复数表示\n- 驼峰式命名，遵循Bean规范\n- 使用版本来控制变更冲突\n- 对于一些关键字，不要拿来做key\n- 如果一个属性是可选的或者包含空值或null值，考虑从JSON中去掉该属性，除非它的存在有很强的语义原因\n- 序列化枚举类型时，使用name而不是value\n- 日期要用标准格式处理\n- 设计好通用的分页参数\n- 设计好异常处理\n\n### 4.2 使用JSON实现API\n[JSON API](http://jsonapi.org.cn/format/)与Google JSON风格指南有很多可以相互参照之处。\n\n[JSON API](http://jsonapi.org.cn/format/)是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求。\n\nJSON API设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性。\n\n## 5. REST\n todo list\n - dubbox\n - resteasy\n - restlet\n - jersey\n \n![image](https://github.com/kimmking/kk/blob/master/images/json/rest.jpg?raw=true)\n\n## 6. SwaggerUI实现API文档管理与在线测试\n todo list\n \n![image](https://github.com/kimmking/kk/blob/master/images/json/json03.png?raw=true)\n\n## 7. JSON使用场景分析\nJSON的使用，依据不同用途，有几个典型的场景：\n1. 内部后台系统之间的数据传输，此种情况下基于HTTP的JSON格式其实没有优势。\n2. 前后台之间的API调用，典型的是前端作为React/VUE/AngularJS/ExtJS等框架做的，前后端使用JSON交互。\n- 此时可以使用类似Dubbox之类的框架，或者原始一些SpringMVC的Controller上直接@ResponseBody或@RestController也可以。\n- 强烈建议在Dubbox之类的rest之上再加一个Nginx转发，这样一些策略的控制，比如同源的控制、简单的缓存策略、安全策略等都可以放到Nginx上来做，也利于多个机器时的负载均衡。\n- 建议使用swaggerUI来自动实现API文档和在线测试。功能很强大，操作简单，而且可以mock接口，在后台没有做好之前，前台就可以先开发了。\n- 可以使用RestUnit或SoapUI来实现自动化测试与压力测试。\n\n3. 提供给第三方的开发接口API\n基本同上，可以参考Google JSON风格指南与JSON API章节。\n\n## 8.JSON的一些经验\n最近在协助处理一些Fastjson的bug问题，发现最常见的其实是大家使用的不规范性，这样碰到各种坑的可能性就很大。根据我平时使用的经验，以及总结大家常见的问题，归纳如下：\n\n### 7.1 遵循Java Beans规范与JSON规范\n实践告诉我们：遵循beans规范和JSON规范的方式，能减少大部分的问题，比如正确实现setter、getter，用别名就加annotation。注意基本类型的匹配转换，比如在fastjson的issue见到试图把\"{\"a\":{}}\"中的a转换成List的。\n\n### 7.2 使用正常的key\n尽量不要使用数字等字符开头的key，尽量使用符合Java的class或property命名规范的key，这样会减少不必要的冲突。在jsonpath或js里，a.1可能会被解释成a[1]或a[\"1\"]，这些都会带来不必要的麻烦。\n\n### 7.3 关于日期处理\n这一点前面的Google JSON风格指南里也提到了，尽量使用标准的日期格式。或者序列化和反序列化里都是用同样的datePattern格式。\n\n### 7.4 关于自定义序列化与反序列化（包括过滤器）\n对于新手来说，自定义序列化是一切罪恶的根源。\n\n尽量不要使用自定义序列化，除非万不得已，优先考虑使用注解过滤，别名等方式，甚至是重新建一个VO类来组装实际需要的属性。使用自定义序列化时一切要小心，因为这样会导致两个问题：\n- 改变了pojo <-> jsonstring 的自然对应关系，从而不利于阅读代码和排查问题，你改变的关系无法简单的从bean和json上看出来了；\n- 反序列化可能出错，因为对应不上原来的属性了。\n\n如果只是序列化发出去（响应）的是JSON数据、传过来（请求）的数据格式跟JSON无关或者是标准的，此时自定义序列化就无所谓了，反正是要接收方来处理。\n\n### 7.5 JSONObject的使用\nJSONObject是JSON字符串与pojo对象转换过程中的中间表达类型，实现了Map接口，可以看做是一个模拟JSON对象键值对再加上多层嵌套的数据集合，对象的每一个基本类型属性是map里的一个key-value，一个非基本类型属性是一个嵌套的JSONObject对象（key是属性名称，value是表示这个属性值的对象的JSONObject）。如果以前用过apache beanutils里的DynamicBean之类的，就知道JSONObject也是一种动态描述Bean的实现，相当于是拆解了Bean本身的结构与数据。这时候由于JSONObject里可能会没有记录全部的Bean类型数据，例如泛型的具体子类型之类的元数据，如果JSONObject与正常的POJO混用，出现问题的概率较高。\n下列方式尽量不要使用：\n\n```java\npublic class TestBean{\n    @Setter @Getter\n    private TestBean1 testBean1;\n    \n    @Setter @Getter\n    private JSONObject testBean2; // 尽量不要在POJO里用JSONObject\n}\n```\n\n应该从设计上改为都用POJO比较合适:\n\n```java\npublic class TestBean{\n    @Setter @Getter\n    private TestBean1 testBean1;\n    \n    @Setter @Getter\n    private TestBean2 testBean2;; // 使用POJO\n}\n```\n相对的，写一些临时性的测试代码，demo代码，可以直接全部用JSONObject先快速run起来。\n\n同理，jsonstring中嵌套jsonstring也尽量不要用，例如：\n\n```javascript\n{\n    \"name\":\"zhangsan\",\n    \"score\":\"{\\\"math\\\":78,\\\"history\\\":82}\"\n}\n```\n\n应该改为全部都是JSON风格的结构：\n\n```javascript\n{\n    \"name\":\"zhangsan\",\n    \"score\":{\n        \"math\":78,\n        \"history\":82\n    }\n}\n```\n\n另外，对于jsonstring转POJO（或POJO转jsonstring），尽量使用直接转的方式，而不是先转成JSONObject过渡的方式。特别是对于Fastjson，由于性能优化的考虑，这两个执行的代码是不一样的，可能导致不一样的结果。\n\n```java\n    String jsonstring = \"{\\\"a\\\":12}\";\n    \n    // 不推荐这种方式\n    // 除非这里需要对jsonObject做一些简单处理\n    JSONObject jsonObject = JSON.parseObject(jsonstring);\n    A a = jsonObject.toJavaObject(A.class);\n    \n    // 推荐方式\n    A a = JSON.parseObject(jsonstring, A.class);\n    \n```\n\n### 7.6 Hibernate相关问题\n懒加载与级联，可能导致出现问题，例如hibernate，建议封装一层VO类型来序列化。使用VO类还有一个好处，就是可以去掉一些没用的属性，减少数据量，同时可以加上额外的属性。\n\n### 7.7 深层嵌套与泛型问题\n尽量不要在使用过多的层次嵌套的同时使用泛型（List、Map等），可能导致类型丢失，而且问题比较难查。\n\n### 7.8 抽象类型与子类型问题\n尽量不要在同一个Bean的层次结构里使用多个子类型对象，可能导致类型丢失，而且问题比较难查。当然我们可以通过代码显示的传递各种正确的类型，但是这样做引入了更多的不确定性。良好的做法应该是一开始设计时就避免出现这些问题。\n\n### 7.9 避免循环引用\n尽量避免循环引用，这个虽然可以通过序列化特性禁掉，但是如果能避免则避免。\n\n### 7.10 注意编码和不可见字符（特别是二进制数据流）\n对于InputStream、OutputStream的处理，有时候会报一些奇怪的错误，not match之类的，这时候也许我们看日志里的json字符串可能很正常，但就是出错。\n\n这时可能就是编码的问题了，可能是导致字符错乱，也可能是因为UTF-8文件的BOM头，这些潜在的问题可能在二进制数据转文本的时候，因为一些不可见字符无法显示，导致日志看起来只有正常字符而是正确的，问题很难排查。\n\n处理办法就是按二进制的方式把Stream保存起来，然后按hex方式查看，看看是否有多余字符，或者其他错误。\n\n## 8.fastjson的最佳实践\n### 8.1 Maven下引入Fastjson\npom.xml文件里添加依赖即可：\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.32</version>\n</dependency>\n```\n\n### 8.2 序列化一个对象成JSON字符串\n\n```java\nUser user = new User();\nuser.setName(\"校长\");\nuser.setAge(3);\nuser.setSalary(new BigDecimal(\"123456789.0123\"));\nString jsonString = JSON.toJSONString(user);\nSystem.out.println(jsonString);\n// 输出 {\"age\":3,\"name\":\"校长\",\"old\":false,\"salary\":123456789.0123}\n```\n\n### 8.3 反序列化一个JSON字符串成Java对象\n\n```java\n String jsonString = \"{\\\"age\\\":3,\\\"birthdate\\\":1496738822842,\\\"name\\\":\\\"校长\\\",\\\"old\\\":true,\\\"salary\\\":123456789.0123}\";\n User u = JSON.parseObject(jsonString ,User.class);\n System.out.println(u.getName());\n // 输出 校长\n\nString jsonStringArray = \"[{\\\"age\\\":3,\\\"birthdate\\\":1496738822842,\\\"name\\\":\\\"校长\\\",\\\"old\\\":true,\\\"salary\\\":123456789.0123}]\";\nList<User> userList = JSON.parseArray(jsonStringArray, User.class);\nSystem.out.println(userList.size());\n// 输出 1\n```\n\n### 8.4 日期格式处理\nFastjson能识别下面这么多种日期格式的字符串：\n\n```java\n    private final static String            defaultPatttern    = \"yyyy-MM-dd HH:mm:ss\";\n    private final static DateTimeFormatter defaultFormatter   = DateTimeFormatter.ofPattern(defaultPatttern);\n    private final static DateTimeFormatter formatter_dt19_tw  = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_cn  = DateTimeFormatter.ofPattern(\"yyyy年M月d日 HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_cn_1  = DateTimeFormatter.ofPattern(\"yyyy年M月d日 H时m分s秒\");\n    private final static DateTimeFormatter formatter_dt19_kr  = DateTimeFormatter.ofPattern(\"yyyy년M월d일 HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_us  = DateTimeFormatter.ofPattern(\"MM/dd/yyyy HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_eur = DateTimeFormatter.ofPattern(\"dd/MM/yyyy HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_de  = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_in  = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n\n    private final static DateTimeFormatter formatter_d8       = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n    private final static DateTimeFormatter formatter_d10_tw   = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\");\n    private final static DateTimeFormatter formatter_d10_cn   = DateTimeFormatter.ofPattern(\"yyyy年M月d日\");\n    private final static DateTimeFormatter formatter_d10_kr   = DateTimeFormatter.ofPattern(\"yyyy년M월d일\");\n    private final static DateTimeFormatter formatter_d10_us   = DateTimeFormatter.ofPattern(\"MM/dd/yyyy\");\n    private final static DateTimeFormatter formatter_d10_eur  = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    private final static DateTimeFormatter formatter_d10_de   = DateTimeFormatter.ofPattern(\"dd.MM.yyyy\");\n    private final static DateTimeFormatter formatter_d10_in   = DateTimeFormatter.ofPattern(\"dd-MM-yyyy\");\n\n    private final static DateTimeFormatter ISO_FIXED_FORMAT =\n            DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").withZone(ZoneId.systemDefault());\n\n    private final static String formatter_iso8601_pattern     = \"yyyy-MM-dd'T'HH:mm:ss\";\n    private final static DateTimeFormatter formatter_iso8601  = DateTimeFormatter.ofPattern(formatter_iso8601_pattern);\n```\n默认序列化Date输出使用\"yyyy-MM-dd HH:mm:ss\"格式，可以用UseISO8601DateFormat特性换成\"yyyy-MM-dd'T'HH:mm:ss\"格式。\n\n\n```java\nJSON.defaultTimeZone = TimeZone.getTimeZone(\"Asia/Shanghai\");\nJSON.defaultLocale = Locale.US;\n        \npublic static class Model {\n        @JSONField(format = \"MMM dd, yyyy h:mm:ss aa\")\n        private java.util.Date date;\n\n        public java.util.Date getDate() {\n            return date;\n        }\n\n        public void setDate(java.util.Date date) {\n            this.date = date;\n        }\n\n        @JSONField(format = \"MMM-dd-yyyy h:mm:ss aa\")\n        public java.sql.Date date2;\n}\n```\n\n### 8.5 常见序列化特性的使用\nFastjson的序列化特性定义在枚举类com\\alibaba\\fastjson\\serializer\\SerializerFeature.java中，目前正好有30项。\n可以通过设置多个特性到FastjsonConfig中全局使用，也可以在某个具体的JSON.writeJSONString时作为参数使用。\n1. QuoteFieldNames, //key使用引号\n2. UseSingleQuotes, //使用单引号\n3. WriteMapNullValue, //输出Map的null值\n4. WriteEnumUsingToString, //枚举属性输出toString的结果\n5. WriteEnumUsingName, //枚举数据输出name\n6. UseISO8601DateFormat, //使用日期格式\n7. WriteNullListAsEmpty, //List为空则输出[]\n8. WriteNullStringAsEmpty, //String为空则输出\"\"\n9. WriteNullNumberAsZero, //Number类型为空则输出0\n10. WriteNullBooleanAsFalse, //Boolean类型为空则输出false\n11. SkipTransientField,\n12. SortField, //排序字段\n13. WriteTabAsSpecial,\n14. PrettyFormat, // 格式化JSON缩进\n15. WriteClassName, // 输出类名\n16. DisableCircularReferenceDetect, // 禁止循环引用\n17. WriteSlashAsSpecial, // 对斜杠’/’进行转义\n18. BrowserCompatible,\n19. WriteDateUseDateFormat, // 全局修改日期格式,默认为false。JSON.DEFFAULT_DATE_FORMAT = “yyyy-MM-dd”;JSON.toJSONString(obj, SerializerFeature.WriteDateUseDateFormat);\n20. NotWriteRootClassName,\n21. DisableCheckSpecialChar,\n22. BeanToArray,\n23. WriteNonStringKeyAsString,\n24. NotWriteDefaultValue,\n25. BrowserSecure,\n26. IgnoreNonFieldGetter,\n27. WriteNonStringValueAsString,\n28. IgnoreErrorGetter,\n29. WriteBigDecimalAsPlain,\n30. MapSortField\n\n\n使用示例如下（可以[参见此处](http://blog.csdn.net/u010246789/article/details/52539576)）：\n\n```java\nWord word = new Word();\nword.setA(\"a\");\nword.setB(2);\nword.setC(true);\nword.setD(\"d\");\nword.setE(\"\");\nword.setF(null);\nword.setDate(new Date());\n\nSystem.out.println(JSON.toJSONString(word));\nSystem.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat,\n    SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty,\n    SerializerFeature.DisableCircularReferenceDetect,\n    SerializerFeature.WriteNullListAsEmpty));\n\n```\n\n### 8.6 Annotation注解的使用\n1) JSONField\n\n可以配置在属性（setter、getter）和字段（必须是public field）上。\n详情参见此处：[JSONField用法](https://github.com/alibaba/fastjson/wiki/JSONField)\n\n```java\npackage com.alibaba.fastjson.annotation;\n\npublic @interface JSONField {\n    // 配置序列化和反序列化的顺序，1.1.42版本之后才支持\n    int ordinal() default 0;\n\n     // 指定字段的名称\n    String name() default \"\";\n\n    // 指定字段的格式，对日期格式有用\n    String format() default \"\";\n\n    // 是否序列化\n    boolean serialize() default true;\n\n    // 是否反序列化\n    boolean deserialize() default true;\n}\n```\n\n```java\n@JSONField(name=\"ID\")\npublic int getId() {return id;}\n\n// 配置date序列化和反序列使用yyyyMMdd日期格式\n@JSONField(format=\"yyyyMMdd\")\npublic Date date1;  \n\n // 不序列化\n @JSONField(serialize=false)\n public Date date2;\n\n // 不反序列化\n @JSONField(deserialize=false)\n public Date date3;\n\n // 按ordinal排序\n @JSONField(ordinal = 2)\n private int f1;\n\n @JSONField(ordinal = 1)\n private int f2;\n    \n```\n\n2) JSONType\n\n- 自定义序列化：[ObjectSerializer](https://github.com/alibaba/fastjson/wiki/JSONType_serializer)\n- 子类型处理：[SeeAlso](https://github.com/alibaba/fastjson/wiki/JSONType_seeAlso_cn)\n- JSONType.alphabetic属性: fastjson缺省时会使用字母序序列化，如果你是希望按照java fields/getters的自然顺序序列化，可以配置JSONType.alphabetic，使用方法如下：\n\n```java\n@JSONType(alphabetic = false)\npublic static class B {\n    public int f2;\n    public int f1;\n    public int f0;\n}\n```\n\n### 8.7 自定义序列化与反序列化\n\n- 自定义序列化\n\n只需要2步：[参见此处](https://github.com/alibaba/fastjson/wiki/ObjectSerializer_cn)\n1)实现ObjectSerializer\n\n```java\npublic class CharacterSerializer implements ObjectSerializer {\n    public void write(JSONSerializer serializer, \n                      Object object, \n                      Object fieldName, \n                      Type fieldType, \n                      int features) throws IOException {\n        SerializeWriter out = serializer.out;\n    \n        Character value = (Character) object;\n        if (value == null) {\n            out.writeString(\"\");\n            return;\n        }\n    \n        char c = value.charValue();\n        if (c == 0) {\n            out.writeString(\"\\u0000\");\n        } else {\n            out.writeString(value.toString());\n        }\n    }\n}\n```\n\n2)注册ObjectSerializer\n\n```java\nSerializeConfig.getGlobalInstance().put(Character.class, new CharacterSerializer());\n```\n\n- 自定义反序列化\n\n只需要2步：[参见此处](https://github.com/alibaba/fastjson/wiki/ObjectDeserializer_cn)\n\n1)自定义实现ObjectDeserializer\n\n```java\npublic static enum OrderActionEnum {\n                                    FAIL(1), SUCC(0);\n\n    private int code;\n\n    OrderActionEnum(int code){\n        this.code = code;\n    }\n}\n\npublic static class Msg {\n\n    public OrderActionEnum actionEnum;\n    public String          body;\n}\n\npublic static class OrderActionEnumDeser implements ObjectDeserializer {\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n        Integer intValue = parser.parseObject(int.class);\n        if (intValue == 1) {\n            return (T) OrderActionEnum.FAIL;\n        } else if (intValue == 0) {\n            return (T) OrderActionEnum.SUCC;\n        }\n        throw new IllegalStateException();\n    }\n\n    @Override\n    public int getFastMatchToken() {\n        return JSONToken.LITERAL_INT;\n    }\n\n}\n```\n\n2)注册并使用ObjectDeserializer\n\n```java\nParserConfig.getGlobalInstance().putDeserializer(OrderActionEnum.class, new OrderActionEnumDeser());\n\n{\n    Msg msg = JSON.parseObject(\"{\\\"actionEnum\\\":1,\\\"body\\\":\\\"A\\\"}\", Msg.class);\n    Assert.assertEquals(msg.body, \"A\");\n    Assert.assertEquals(msg.actionEnum, OrderActionEnum.FAIL);\n}\n{\n    Msg msg = JSON.parseObject(\"{\\\"actionEnum\\\":0,\\\"body\\\":\\\"B\\\"}\", Msg.class);\n    Assert.assertEquals(msg.body, \"B\");\n    Assert.assertEquals(msg.actionEnum, OrderActionEnum.SUCC);\n}\n```\n\n### 8.8 自定义序列化之过滤器\n- 全局的过滤器：JSON.toJSONString方法的参数中可以配置处理所有类型的SerializeFilter\n- 类级别过滤器：[Class_Level_SerializeFilter](https://github.com/alibaba/fastjson/wiki/Class_Level_SerializeFilter)\n- 属性过滤器：[使用PropertyPreFilter过滤属性](https://github.com/alibaba/fastjson/wiki/%E4%BD%BF%E7%94%A8SimplePropertyPreFilter%E8%BF%87%E6%BB%A4%E5%B1%9E%E6%80%A7)\n- 多余字段处理器：[ExtraProcessor 用于处理多余的字段、\nExtraTypeProvider用于处理多余字段时提供类型信息](https://github.com/alibaba/fastjson/wiki/ParseProcess)\n- 定制反序列化：[在fastjson-1.2.9版本后提供了ExtraProcessable接口，用于定制对象的反序列化功能](https://github.com/alibaba/fastjson/wiki/ExtraProcessable)，可用于添加没有的字段\n- 标签过滤：[JSONField(label)，相当于分组](https://github.com/alibaba/fastjson/wiki/LabelFilter)\n- 自动识别嵌套对象子类型：[FieldTypeResolver](https://github.com/alibaba/fastjson/wiki/FieldTypeResolver)\n\n### 8.9 与Spring MVC的配合使用\n\nFastJson 提供了Spring MVC HttpMessageConverter的实现，将POJO输出为JSONP，支持跨域数据访问。\n\nFastJsonpHttpMessageConverter4 for Spring MVC 4.2+：\n\n```xml\n<mvc:annotation-driven>\n    <mvc:message-converters>\n        <bean\n            class=\"com.alibaba.fastjson.support.spring.FastJsonpHttpMessageConverter4\">\n            <property name=\"supportedMediaTypes\">\n                <list>\n                    <value>application/json;charset=UTF-8</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n\n<mvc:default-servlet-handler />\n\n<bean id=\"fastJsonpResponseBodyAdvice\" class=\"com.alibaba.fastjson.support.spring.FastJsonpResponseBodyAdvice\">\n    <constructor-arg>\n        <list>\n            <value>callback</value>\n            <value>jsonp</value>\n        </list>\n    </constructor-arg>\n</bean>\n```\n\n[详细配置参见此处](https://github.com/alibaba/fastjson/wiki/FastJsonpHttpMessageConverter4_CN)\n\n### 8.10 与Spring Boot的集成使用\n\n参见此处：[spring-boot-starter-fastjson](https://github.com/storezhang/utils/tree/master/spring-boot-starter-fastjson)\n\n\n### 8.11 泛型处理\n[在fastjson中提供了一个用于处理泛型反序列化的类TypeReference](https://github.com/alibaba/fastjson/wiki/Typ)eReference\n\n### 8.12jaxrs支持\nFastJson 提供了JAX-RS Provider的实现 [FastJsonProvider](https://github.com/alibaba/fastjson/wiki/FastJsonProvider_CN)\n\n可用于在构建Restful服务时使用FastJson进行数据的Serialize and Deserialize\n\n### 8.13 swagger支持\n\n[增加对swagger的支持](https://github.com/alibaba/fastjson/pull/716)\n\n\n更多功能 todo list\n\n## 9.Fastjson的设计说明\ntodo list\n\n","source":"_posts/json-best-practice.md","raw":"title: JSON最佳实践\ndate: 2017-06-06 23:00:05\ntags: json\n---\nJSON是一种文本方式展示结构化数据的方式，从产生的时候开始就由于其简单好用、跨平台，特别适合HTTP下数据的传输（例如现在很流行的REST）而被广泛使用。\n\n## 1、JSON是什么\nJSON起源于1999年的[JS语言规范ECMA262的一个子集](http://javascript.crockford.com/)（即15.12章节描述了格式与解析），后来2003年作为一个数据格式[ECMA404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)（很囧的序号有不有？）发布。\n2006年，作为[rfc4627](http://www.ietf.org/rfc/rfc4627.txt)发布，这时规范增加到18页，去掉没用的部分，十页不到。\n\nJSON的应用很广泛，这里有超过100种语言下的JSON库：[json.org](http://www.json.org/)。\n\n更多的可以参考这里，[关于json的一切](https://github.com/burningtree/awesome-json)。\n\n\n## 2、优缺点、标准与schema\n### 2.1 结构与类型\n这估计是最简单标准规范之一：\n- 只有两种结构：对象内的键值对集合结构和数组，对象用{}表示、内部是\"key\":\"value\"，数组用[]表示，不同值用逗号分开\n- 基本数值有7个： false / null / true / object / array / number / string\n- 再加上结构可以嵌套，进而可以用来表达复杂的数据\n\n一个简单实例：\n \n```javascript\n\n   {\n      \"Image\": {\n          \"Width\":  800,\n          \"Height\": 600,\n          \"Title\":  \"View from 15th Floor\",\n          \"Thumbnail\": {\n              \"Url\":    \"http://www.example.com/image/481989943\",\n              \"Height\": 125,\n              \"Width\":  \"100\"\n          },\n          \"IDs\": [116, 943, 234, 38793]\n        }\n   }\n\n\n```\n\n### 2.2 优点\n- 基于纯文本，所以对于人类阅读是很友好的。\n- 规范简单，所以容易处理，开箱即用，特别是JS类的ECMA脚本里是内建支持的，可以直接作为对象使用。\n- 平台无关性，因为类型和结构都是平台无关的，而且好处理，容易实现不同语言的处理类库，可以作为多个不同异构系统之间的数据传输格式协议，特别是在HTTP/REST下的数据格式。\n\n### 2.3 缺点\n缺点也很明显：\n- 性能一般，文本表示的数据一般来说比二进制大得多，在数据传输上和解析处理上都要更影响性能。\n- 缺乏schema，跟同是文本数据格式的XML比，在类型的严格性和丰富性上要差很多。XML可以借由XSD或DTD来定义复杂的格式，并由此来验证XML文档是否符合格式要求，甚至进一步的，可以基于XSD来生成具体语言的操作代码，例如apache xmlbeans。并且这些工具组合到一起，形成一套庞大的生态，例如基于XML可以实现SOAP和WSDL，一系列的ws-*规范。但是我们也可以看到JSON在缺乏规范的情况下，实际上有更大一些的灵活性，特别是近年来REST的快速发展，已经有一些schema相关的发展(例如[理解JSON Schema](https://spacetelescope.github.io/understanding-json-schema/index.html)，[使用JSON Schema](http://usingjsonschema.com/downloads/)， [在线schema测试](http://azimi.me/json-schema-view/demo/demo.html))，也有类似于WSDL的[WADL](https://www.w3.org/Submission/wadl/)出现。\n\n## 3. 常用技术与工具\n### 3.1 相关技术以及与XML的关系\n- 使用JSON实现RPC（类似XML-RPC）：[JSON-RPC](http://www.jsonrpc.org/)\n- 使用JSON实现path查询操作（类似XML-PATH）：[JsonPATH](https://github.com/json-path/JsonPath)\n- 在线查询工具：[JsonPATH](http://jsonpath.com/)\n \n例如上面的示例json，用表达式$.Image.IDs[:1]查询，得到116：\n![image](https://raw.githubusercontent.com/kimmking/kk/master/images/json/jsonpath.png)\n\n\n我们看到JSON与XML是如此之像，实际上这两个格式可以看做一个是学院排，一个是平民派。一个对象从POJO转换成XML与JSON的过程，基本是一致的（绝大部分工作可以复用，以后有机会再详细聊这个过程），10年前我自己也做过一个基于XML的RPC（[http://code.google.com/p/rpcfx/](http://code.google.com/p/rpcfx/)，貌似已经被墙），里面实现了java和dotnet、JS的XML序列化与反序列化，同时作为一个副产品，实现了JSON序列化。\n\n后来thoughtsworks公司出品的XStream就是同时做了XML与JSON的序列化。而创建Jackson库的组织本来叫fasterxml，就是处理xml的。当然从这个角度来看，Fastjson库，稍微改改也是一个高性能的XML序列化库。\n只是XML有着更严格的结构，更丰富的工具生态，拿查询与操作来说，XML还有XQuery、XLST等工具。处理方式上也有DOM方式与SAX流模式，这两个绝然不同的技术。\n\n单从性能来考虑，XML更是有[VTD-XML](http://vtd-xml.sourceforge.net/)这种解决了DOM消耗太大内存与SAX只能单向每个节点读一次不能随机读的缺点的高性能处理方式。\n\n### 3.2 Java类库\n- [Fastjson](https://github.com/alibaba/fastjson)\n- [Jackson](http://wiki.fasterxml.com/JacksonHome)\n- [Gson](https://github.com/google/gson)\n- [Xstream](http://x-stream.github.io/)\n\n### 3.3 工具\n- 格式化工具：[jsbeautifier](http://jsbeautifier.org/)\n- chrome插件：[5个Json View插件](http://www.cnplugins.com/zhuanti/five-chrome-json-plugins.html)\n- 在线Mock: [在线mock](https://www.easy-mock.com/)\n- 其他Mock：[SoapUI](https://www.soapui.org/rest-testing-mocking/rest-service-mocking.html)可以支持，SwaggerUI也可以，[RestMock](https://github.com/andrzejchm/RESTMock)也可以。\n\n![image](https://github.com/kimmking/kk/blob/master/images/json/json01.png?raw=true)\n![image](https://github.com/kimmking/kk/blob/master/images/json/json02.png?raw=true)\n\n## 4. JSON编码指南\n### 4.1 Google JSON风格指南\n遵循好的设计与编码风格，能提前解决80%的问题:\n- 英文版[Google JSON Style Guide](https://google.github.io/styleguide/jsoncstyleguide.xml)：https://google.github.io/styleguide/jsoncstyleguide.xml\n- 中文版[Google JSON风格指南](https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md)：https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md\n\n简单摘录如下：\n- 属性名和值都是用双引号，不要把注释写到对象里面，对象数据要简洁\n- 不要随意结构化分组对象，推荐是用扁平化方式，层次不要太复杂\n- 命名方式要有意义，比如单复数表示\n- 驼峰式命名，遵循Bean规范\n- 使用版本来控制变更冲突\n- 对于一些关键字，不要拿来做key\n- 如果一个属性是可选的或者包含空值或null值，考虑从JSON中去掉该属性，除非它的存在有很强的语义原因\n- 序列化枚举类型时，使用name而不是value\n- 日期要用标准格式处理\n- 设计好通用的分页参数\n- 设计好异常处理\n\n### 4.2 使用JSON实现API\n[JSON API](http://jsonapi.org.cn/format/)与Google JSON风格指南有很多可以相互参照之处。\n\n[JSON API](http://jsonapi.org.cn/format/)是数据交互规范，用以定义客户端如何获取与修改资源，以及服务器如何响应对应请求。\n\nJSON API设计用来最小化请求的数量，以及客户端与服务器间传输的数据量。在高效实现的同时，无需牺牲可读性、灵活性和可发现性。\n\n## 5. REST\n todo list\n - dubbox\n - resteasy\n - restlet\n - jersey\n \n![image](https://github.com/kimmking/kk/blob/master/images/json/rest.jpg?raw=true)\n\n## 6. SwaggerUI实现API文档管理与在线测试\n todo list\n \n![image](https://github.com/kimmking/kk/blob/master/images/json/json03.png?raw=true)\n\n## 7. JSON使用场景分析\nJSON的使用，依据不同用途，有几个典型的场景：\n1. 内部后台系统之间的数据传输，此种情况下基于HTTP的JSON格式其实没有优势。\n2. 前后台之间的API调用，典型的是前端作为React/VUE/AngularJS/ExtJS等框架做的，前后端使用JSON交互。\n- 此时可以使用类似Dubbox之类的框架，或者原始一些SpringMVC的Controller上直接@ResponseBody或@RestController也可以。\n- 强烈建议在Dubbox之类的rest之上再加一个Nginx转发，这样一些策略的控制，比如同源的控制、简单的缓存策略、安全策略等都可以放到Nginx上来做，也利于多个机器时的负载均衡。\n- 建议使用swaggerUI来自动实现API文档和在线测试。功能很强大，操作简单，而且可以mock接口，在后台没有做好之前，前台就可以先开发了。\n- 可以使用RestUnit或SoapUI来实现自动化测试与压力测试。\n\n3. 提供给第三方的开发接口API\n基本同上，可以参考Google JSON风格指南与JSON API章节。\n\n## 8.JSON的一些经验\n最近在协助处理一些Fastjson的bug问题，发现最常见的其实是大家使用的不规范性，这样碰到各种坑的可能性就很大。根据我平时使用的经验，以及总结大家常见的问题，归纳如下：\n\n### 7.1 遵循Java Beans规范与JSON规范\n实践告诉我们：遵循beans规范和JSON规范的方式，能减少大部分的问题，比如正确实现setter、getter，用别名就加annotation。注意基本类型的匹配转换，比如在fastjson的issue见到试图把\"{\"a\":{}}\"中的a转换成List的。\n\n### 7.2 使用正常的key\n尽量不要使用数字等字符开头的key，尽量使用符合Java的class或property命名规范的key，这样会减少不必要的冲突。在jsonpath或js里，a.1可能会被解释成a[1]或a[\"1\"]，这些都会带来不必要的麻烦。\n\n### 7.3 关于日期处理\n这一点前面的Google JSON风格指南里也提到了，尽量使用标准的日期格式。或者序列化和反序列化里都是用同样的datePattern格式。\n\n### 7.4 关于自定义序列化与反序列化（包括过滤器）\n对于新手来说，自定义序列化是一切罪恶的根源。\n\n尽量不要使用自定义序列化，除非万不得已，优先考虑使用注解过滤，别名等方式，甚至是重新建一个VO类来组装实际需要的属性。使用自定义序列化时一切要小心，因为这样会导致两个问题：\n- 改变了pojo <-> jsonstring 的自然对应关系，从而不利于阅读代码和排查问题，你改变的关系无法简单的从bean和json上看出来了；\n- 反序列化可能出错，因为对应不上原来的属性了。\n\n如果只是序列化发出去（响应）的是JSON数据、传过来（请求）的数据格式跟JSON无关或者是标准的，此时自定义序列化就无所谓了，反正是要接收方来处理。\n\n### 7.5 JSONObject的使用\nJSONObject是JSON字符串与pojo对象转换过程中的中间表达类型，实现了Map接口，可以看做是一个模拟JSON对象键值对再加上多层嵌套的数据集合，对象的每一个基本类型属性是map里的一个key-value，一个非基本类型属性是一个嵌套的JSONObject对象（key是属性名称，value是表示这个属性值的对象的JSONObject）。如果以前用过apache beanutils里的DynamicBean之类的，就知道JSONObject也是一种动态描述Bean的实现，相当于是拆解了Bean本身的结构与数据。这时候由于JSONObject里可能会没有记录全部的Bean类型数据，例如泛型的具体子类型之类的元数据，如果JSONObject与正常的POJO混用，出现问题的概率较高。\n下列方式尽量不要使用：\n\n```java\npublic class TestBean{\n    @Setter @Getter\n    private TestBean1 testBean1;\n    \n    @Setter @Getter\n    private JSONObject testBean2; // 尽量不要在POJO里用JSONObject\n}\n```\n\n应该从设计上改为都用POJO比较合适:\n\n```java\npublic class TestBean{\n    @Setter @Getter\n    private TestBean1 testBean1;\n    \n    @Setter @Getter\n    private TestBean2 testBean2;; // 使用POJO\n}\n```\n相对的，写一些临时性的测试代码，demo代码，可以直接全部用JSONObject先快速run起来。\n\n同理，jsonstring中嵌套jsonstring也尽量不要用，例如：\n\n```javascript\n{\n    \"name\":\"zhangsan\",\n    \"score\":\"{\\\"math\\\":78,\\\"history\\\":82}\"\n}\n```\n\n应该改为全部都是JSON风格的结构：\n\n```javascript\n{\n    \"name\":\"zhangsan\",\n    \"score\":{\n        \"math\":78,\n        \"history\":82\n    }\n}\n```\n\n另外，对于jsonstring转POJO（或POJO转jsonstring），尽量使用直接转的方式，而不是先转成JSONObject过渡的方式。特别是对于Fastjson，由于性能优化的考虑，这两个执行的代码是不一样的，可能导致不一样的结果。\n\n```java\n    String jsonstring = \"{\\\"a\\\":12}\";\n    \n    // 不推荐这种方式\n    // 除非这里需要对jsonObject做一些简单处理\n    JSONObject jsonObject = JSON.parseObject(jsonstring);\n    A a = jsonObject.toJavaObject(A.class);\n    \n    // 推荐方式\n    A a = JSON.parseObject(jsonstring, A.class);\n    \n```\n\n### 7.6 Hibernate相关问题\n懒加载与级联，可能导致出现问题，例如hibernate，建议封装一层VO类型来序列化。使用VO类还有一个好处，就是可以去掉一些没用的属性，减少数据量，同时可以加上额外的属性。\n\n### 7.7 深层嵌套与泛型问题\n尽量不要在使用过多的层次嵌套的同时使用泛型（List、Map等），可能导致类型丢失，而且问题比较难查。\n\n### 7.8 抽象类型与子类型问题\n尽量不要在同一个Bean的层次结构里使用多个子类型对象，可能导致类型丢失，而且问题比较难查。当然我们可以通过代码显示的传递各种正确的类型，但是这样做引入了更多的不确定性。良好的做法应该是一开始设计时就避免出现这些问题。\n\n### 7.9 避免循环引用\n尽量避免循环引用，这个虽然可以通过序列化特性禁掉，但是如果能避免则避免。\n\n### 7.10 注意编码和不可见字符（特别是二进制数据流）\n对于InputStream、OutputStream的处理，有时候会报一些奇怪的错误，not match之类的，这时候也许我们看日志里的json字符串可能很正常，但就是出错。\n\n这时可能就是编码的问题了，可能是导致字符错乱，也可能是因为UTF-8文件的BOM头，这些潜在的问题可能在二进制数据转文本的时候，因为一些不可见字符无法显示，导致日志看起来只有正常字符而是正确的，问题很难排查。\n\n处理办法就是按二进制的方式把Stream保存起来，然后按hex方式查看，看看是否有多余字符，或者其他错误。\n\n## 8.fastjson的最佳实践\n### 8.1 Maven下引入Fastjson\npom.xml文件里添加依赖即可：\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.32</version>\n</dependency>\n```\n\n### 8.2 序列化一个对象成JSON字符串\n\n```java\nUser user = new User();\nuser.setName(\"校长\");\nuser.setAge(3);\nuser.setSalary(new BigDecimal(\"123456789.0123\"));\nString jsonString = JSON.toJSONString(user);\nSystem.out.println(jsonString);\n// 输出 {\"age\":3,\"name\":\"校长\",\"old\":false,\"salary\":123456789.0123}\n```\n\n### 8.3 反序列化一个JSON字符串成Java对象\n\n```java\n String jsonString = \"{\\\"age\\\":3,\\\"birthdate\\\":1496738822842,\\\"name\\\":\\\"校长\\\",\\\"old\\\":true,\\\"salary\\\":123456789.0123}\";\n User u = JSON.parseObject(jsonString ,User.class);\n System.out.println(u.getName());\n // 输出 校长\n\nString jsonStringArray = \"[{\\\"age\\\":3,\\\"birthdate\\\":1496738822842,\\\"name\\\":\\\"校长\\\",\\\"old\\\":true,\\\"salary\\\":123456789.0123}]\";\nList<User> userList = JSON.parseArray(jsonStringArray, User.class);\nSystem.out.println(userList.size());\n// 输出 1\n```\n\n### 8.4 日期格式处理\nFastjson能识别下面这么多种日期格式的字符串：\n\n```java\n    private final static String            defaultPatttern    = \"yyyy-MM-dd HH:mm:ss\";\n    private final static DateTimeFormatter defaultFormatter   = DateTimeFormatter.ofPattern(defaultPatttern);\n    private final static DateTimeFormatter formatter_dt19_tw  = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_cn  = DateTimeFormatter.ofPattern(\"yyyy年M月d日 HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_cn_1  = DateTimeFormatter.ofPattern(\"yyyy年M月d日 H时m分s秒\");\n    private final static DateTimeFormatter formatter_dt19_kr  = DateTimeFormatter.ofPattern(\"yyyy년M월d일 HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_us  = DateTimeFormatter.ofPattern(\"MM/dd/yyyy HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_eur = DateTimeFormatter.ofPattern(\"dd/MM/yyyy HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_de  = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm:ss\");\n    private final static DateTimeFormatter formatter_dt19_in  = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n\n    private final static DateTimeFormatter formatter_d8       = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n    private final static DateTimeFormatter formatter_d10_tw   = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\");\n    private final static DateTimeFormatter formatter_d10_cn   = DateTimeFormatter.ofPattern(\"yyyy年M月d日\");\n    private final static DateTimeFormatter formatter_d10_kr   = DateTimeFormatter.ofPattern(\"yyyy년M월d일\");\n    private final static DateTimeFormatter formatter_d10_us   = DateTimeFormatter.ofPattern(\"MM/dd/yyyy\");\n    private final static DateTimeFormatter formatter_d10_eur  = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    private final static DateTimeFormatter formatter_d10_de   = DateTimeFormatter.ofPattern(\"dd.MM.yyyy\");\n    private final static DateTimeFormatter formatter_d10_in   = DateTimeFormatter.ofPattern(\"dd-MM-yyyy\");\n\n    private final static DateTimeFormatter ISO_FIXED_FORMAT =\n            DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").withZone(ZoneId.systemDefault());\n\n    private final static String formatter_iso8601_pattern     = \"yyyy-MM-dd'T'HH:mm:ss\";\n    private final static DateTimeFormatter formatter_iso8601  = DateTimeFormatter.ofPattern(formatter_iso8601_pattern);\n```\n默认序列化Date输出使用\"yyyy-MM-dd HH:mm:ss\"格式，可以用UseISO8601DateFormat特性换成\"yyyy-MM-dd'T'HH:mm:ss\"格式。\n\n\n```java\nJSON.defaultTimeZone = TimeZone.getTimeZone(\"Asia/Shanghai\");\nJSON.defaultLocale = Locale.US;\n        \npublic static class Model {\n        @JSONField(format = \"MMM dd, yyyy h:mm:ss aa\")\n        private java.util.Date date;\n\n        public java.util.Date getDate() {\n            return date;\n        }\n\n        public void setDate(java.util.Date date) {\n            this.date = date;\n        }\n\n        @JSONField(format = \"MMM-dd-yyyy h:mm:ss aa\")\n        public java.sql.Date date2;\n}\n```\n\n### 8.5 常见序列化特性的使用\nFastjson的序列化特性定义在枚举类com\\alibaba\\fastjson\\serializer\\SerializerFeature.java中，目前正好有30项。\n可以通过设置多个特性到FastjsonConfig中全局使用，也可以在某个具体的JSON.writeJSONString时作为参数使用。\n1. QuoteFieldNames, //key使用引号\n2. UseSingleQuotes, //使用单引号\n3. WriteMapNullValue, //输出Map的null值\n4. WriteEnumUsingToString, //枚举属性输出toString的结果\n5. WriteEnumUsingName, //枚举数据输出name\n6. UseISO8601DateFormat, //使用日期格式\n7. WriteNullListAsEmpty, //List为空则输出[]\n8. WriteNullStringAsEmpty, //String为空则输出\"\"\n9. WriteNullNumberAsZero, //Number类型为空则输出0\n10. WriteNullBooleanAsFalse, //Boolean类型为空则输出false\n11. SkipTransientField,\n12. SortField, //排序字段\n13. WriteTabAsSpecial,\n14. PrettyFormat, // 格式化JSON缩进\n15. WriteClassName, // 输出类名\n16. DisableCircularReferenceDetect, // 禁止循环引用\n17. WriteSlashAsSpecial, // 对斜杠’/’进行转义\n18. BrowserCompatible,\n19. WriteDateUseDateFormat, // 全局修改日期格式,默认为false。JSON.DEFFAULT_DATE_FORMAT = “yyyy-MM-dd”;JSON.toJSONString(obj, SerializerFeature.WriteDateUseDateFormat);\n20. NotWriteRootClassName,\n21. DisableCheckSpecialChar,\n22. BeanToArray,\n23. WriteNonStringKeyAsString,\n24. NotWriteDefaultValue,\n25. BrowserSecure,\n26. IgnoreNonFieldGetter,\n27. WriteNonStringValueAsString,\n28. IgnoreErrorGetter,\n29. WriteBigDecimalAsPlain,\n30. MapSortField\n\n\n使用示例如下（可以[参见此处](http://blog.csdn.net/u010246789/article/details/52539576)）：\n\n```java\nWord word = new Word();\nword.setA(\"a\");\nword.setB(2);\nword.setC(true);\nword.setD(\"d\");\nword.setE(\"\");\nword.setF(null);\nword.setDate(new Date());\n\nSystem.out.println(JSON.toJSONString(word));\nSystem.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat,\n    SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty,\n    SerializerFeature.DisableCircularReferenceDetect,\n    SerializerFeature.WriteNullListAsEmpty));\n\n```\n\n### 8.6 Annotation注解的使用\n1) JSONField\n\n可以配置在属性（setter、getter）和字段（必须是public field）上。\n详情参见此处：[JSONField用法](https://github.com/alibaba/fastjson/wiki/JSONField)\n\n```java\npackage com.alibaba.fastjson.annotation;\n\npublic @interface JSONField {\n    // 配置序列化和反序列化的顺序，1.1.42版本之后才支持\n    int ordinal() default 0;\n\n     // 指定字段的名称\n    String name() default \"\";\n\n    // 指定字段的格式，对日期格式有用\n    String format() default \"\";\n\n    // 是否序列化\n    boolean serialize() default true;\n\n    // 是否反序列化\n    boolean deserialize() default true;\n}\n```\n\n```java\n@JSONField(name=\"ID\")\npublic int getId() {return id;}\n\n// 配置date序列化和反序列使用yyyyMMdd日期格式\n@JSONField(format=\"yyyyMMdd\")\npublic Date date1;  \n\n // 不序列化\n @JSONField(serialize=false)\n public Date date2;\n\n // 不反序列化\n @JSONField(deserialize=false)\n public Date date3;\n\n // 按ordinal排序\n @JSONField(ordinal = 2)\n private int f1;\n\n @JSONField(ordinal = 1)\n private int f2;\n    \n```\n\n2) JSONType\n\n- 自定义序列化：[ObjectSerializer](https://github.com/alibaba/fastjson/wiki/JSONType_serializer)\n- 子类型处理：[SeeAlso](https://github.com/alibaba/fastjson/wiki/JSONType_seeAlso_cn)\n- JSONType.alphabetic属性: fastjson缺省时会使用字母序序列化，如果你是希望按照java fields/getters的自然顺序序列化，可以配置JSONType.alphabetic，使用方法如下：\n\n```java\n@JSONType(alphabetic = false)\npublic static class B {\n    public int f2;\n    public int f1;\n    public int f0;\n}\n```\n\n### 8.7 自定义序列化与反序列化\n\n- 自定义序列化\n\n只需要2步：[参见此处](https://github.com/alibaba/fastjson/wiki/ObjectSerializer_cn)\n1)实现ObjectSerializer\n\n```java\npublic class CharacterSerializer implements ObjectSerializer {\n    public void write(JSONSerializer serializer, \n                      Object object, \n                      Object fieldName, \n                      Type fieldType, \n                      int features) throws IOException {\n        SerializeWriter out = serializer.out;\n    \n        Character value = (Character) object;\n        if (value == null) {\n            out.writeString(\"\");\n            return;\n        }\n    \n        char c = value.charValue();\n        if (c == 0) {\n            out.writeString(\"\\u0000\");\n        } else {\n            out.writeString(value.toString());\n        }\n    }\n}\n```\n\n2)注册ObjectSerializer\n\n```java\nSerializeConfig.getGlobalInstance().put(Character.class, new CharacterSerializer());\n```\n\n- 自定义反序列化\n\n只需要2步：[参见此处](https://github.com/alibaba/fastjson/wiki/ObjectDeserializer_cn)\n\n1)自定义实现ObjectDeserializer\n\n```java\npublic static enum OrderActionEnum {\n                                    FAIL(1), SUCC(0);\n\n    private int code;\n\n    OrderActionEnum(int code){\n        this.code = code;\n    }\n}\n\npublic static class Msg {\n\n    public OrderActionEnum actionEnum;\n    public String          body;\n}\n\npublic static class OrderActionEnumDeser implements ObjectDeserializer {\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n        Integer intValue = parser.parseObject(int.class);\n        if (intValue == 1) {\n            return (T) OrderActionEnum.FAIL;\n        } else if (intValue == 0) {\n            return (T) OrderActionEnum.SUCC;\n        }\n        throw new IllegalStateException();\n    }\n\n    @Override\n    public int getFastMatchToken() {\n        return JSONToken.LITERAL_INT;\n    }\n\n}\n```\n\n2)注册并使用ObjectDeserializer\n\n```java\nParserConfig.getGlobalInstance().putDeserializer(OrderActionEnum.class, new OrderActionEnumDeser());\n\n{\n    Msg msg = JSON.parseObject(\"{\\\"actionEnum\\\":1,\\\"body\\\":\\\"A\\\"}\", Msg.class);\n    Assert.assertEquals(msg.body, \"A\");\n    Assert.assertEquals(msg.actionEnum, OrderActionEnum.FAIL);\n}\n{\n    Msg msg = JSON.parseObject(\"{\\\"actionEnum\\\":0,\\\"body\\\":\\\"B\\\"}\", Msg.class);\n    Assert.assertEquals(msg.body, \"B\");\n    Assert.assertEquals(msg.actionEnum, OrderActionEnum.SUCC);\n}\n```\n\n### 8.8 自定义序列化之过滤器\n- 全局的过滤器：JSON.toJSONString方法的参数中可以配置处理所有类型的SerializeFilter\n- 类级别过滤器：[Class_Level_SerializeFilter](https://github.com/alibaba/fastjson/wiki/Class_Level_SerializeFilter)\n- 属性过滤器：[使用PropertyPreFilter过滤属性](https://github.com/alibaba/fastjson/wiki/%E4%BD%BF%E7%94%A8SimplePropertyPreFilter%E8%BF%87%E6%BB%A4%E5%B1%9E%E6%80%A7)\n- 多余字段处理器：[ExtraProcessor 用于处理多余的字段、\nExtraTypeProvider用于处理多余字段时提供类型信息](https://github.com/alibaba/fastjson/wiki/ParseProcess)\n- 定制反序列化：[在fastjson-1.2.9版本后提供了ExtraProcessable接口，用于定制对象的反序列化功能](https://github.com/alibaba/fastjson/wiki/ExtraProcessable)，可用于添加没有的字段\n- 标签过滤：[JSONField(label)，相当于分组](https://github.com/alibaba/fastjson/wiki/LabelFilter)\n- 自动识别嵌套对象子类型：[FieldTypeResolver](https://github.com/alibaba/fastjson/wiki/FieldTypeResolver)\n\n### 8.9 与Spring MVC的配合使用\n\nFastJson 提供了Spring MVC HttpMessageConverter的实现，将POJO输出为JSONP，支持跨域数据访问。\n\nFastJsonpHttpMessageConverter4 for Spring MVC 4.2+：\n\n```xml\n<mvc:annotation-driven>\n    <mvc:message-converters>\n        <bean\n            class=\"com.alibaba.fastjson.support.spring.FastJsonpHttpMessageConverter4\">\n            <property name=\"supportedMediaTypes\">\n                <list>\n                    <value>application/json;charset=UTF-8</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n\n<mvc:default-servlet-handler />\n\n<bean id=\"fastJsonpResponseBodyAdvice\" class=\"com.alibaba.fastjson.support.spring.FastJsonpResponseBodyAdvice\">\n    <constructor-arg>\n        <list>\n            <value>callback</value>\n            <value>jsonp</value>\n        </list>\n    </constructor-arg>\n</bean>\n```\n\n[详细配置参见此处](https://github.com/alibaba/fastjson/wiki/FastJsonpHttpMessageConverter4_CN)\n\n### 8.10 与Spring Boot的集成使用\n\n参见此处：[spring-boot-starter-fastjson](https://github.com/storezhang/utils/tree/master/spring-boot-starter-fastjson)\n\n\n### 8.11 泛型处理\n[在fastjson中提供了一个用于处理泛型反序列化的类TypeReference](https://github.com/alibaba/fastjson/wiki/Typ)eReference\n\n### 8.12jaxrs支持\nFastJson 提供了JAX-RS Provider的实现 [FastJsonProvider](https://github.com/alibaba/fastjson/wiki/FastJsonProvider_CN)\n\n可用于在构建Restful服务时使用FastJson进行数据的Serialize and Deserialize\n\n### 8.13 swagger支持\n\n[增加对swagger的支持](https://github.com/alibaba/fastjson/pull/716)\n\n\n更多功能 todo list\n\n## 9.Fastjson的设计说明\ntodo list\n\n","slug":"json-best-practice","published":1,"updated":"2017-06-06T15:07:53.387Z","_id":"cj3lp165v00050wkcrc96yscy","comments":1,"layout":"post","photos":[],"link":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj3lp165q00020wkcxsgabo3a","tag_id":"cj3lp165r00030wkcjoji7w11","_id":"cj3lp165u00040wkcd68qm6pn"},{"post_id":"cj3lp165v00050wkcrc96yscy","tag_id":"cj3lp165x00060wkc109yttsb","_id":"cj3lp165x00070wkcj2c7ehvn"}],"Tag":[{"name":"oracle mysql database","_id":"cj3lp165r00030wkcjoji7w11"},{"name":"json","_id":"cj3lp165x00060wkc109yttsb"}]}}